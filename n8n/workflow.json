{
  "name": "Generate Document Embeddings (Cohere)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-embedding",
        "responseMode": "responseNode",
        "options": {}
      },
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "generate-embedding"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, user_id, content, original_filename FROM documents WHERE id = '{{ $json.body.document_id }}'::uuid",
        "options": {}
      },
      "name": "Get Document",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [450, 300],
      "credentials": {
        "postgres": {
          "name": "PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Chunk the document content for embedding\nconst document = $input.first().json;\nconst content = document.content || '';\n\n// Split into chunks of ~2000 chars\nconst chunkSize = 2000;\nconst chunks = [];\n\nfor (let i = 0; i < content.length; i += chunkSize) {\n  chunks.push(content.substring(i, i + chunkSize));\n}\n\n// Take first 5 chunks to avoid rate limits (covers ~10k chars)\nconst limitedChunks = chunks.slice(0, 5);\n\nreturn limitedChunks.map((chunk, index) => ({\n  json: {\n    document_id: document.id,\n    user_id: document.user_id,\n    chunk_index: index,\n    chunk_text: chunk,\n    total_chunks: limitedChunks.length,\n    original_filename: document.original_filename\n  }\n}));"
      },
      "name": "Chunk Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cohere.ai/v1/embed",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.COHERE_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "texts",
              "value": "=[\"{{ $json.chunk_text }}\"]"
            },
            {
              "name": "model",
              "value": "embed-english-v3.0"
            },
            {
              "name": "input_type",
              "value": "search_document"
            }
          ]
        },
        "options": {}
      },
      "name": "Cohere Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [850, 300]
    },
    {
      "parameters": {
        "jsCode": "// Average all chunk embeddings into single document embedding\nconst items = $input.all();\n\nif (items.length === 0) {\n  throw new Error('No embeddings received');\n}\n\n// Extract embeddings from Cohere response\nconst embeddings = items.map(item => {\n  const cohereResponse = item.json;\n  // Cohere returns embeddings in 'embeddings' array\n  return cohereResponse.embeddings[0];\n});\n\n// Get dimensions from first embedding\nconst dimensions = embeddings[0].length;\n\n// Average across all chunk embeddings\nconst avgEmbedding = [];\nfor (let i = 0; i < dimensions; i++) {\n  let sum = 0;\n  for (let j = 0; j < embeddings.length; j++) {\n    sum += embeddings[j][i];\n  }\n  avgEmbedding.push(sum / embeddings.length);\n}\n\n// Truncate to 768 dimensions (Cohere returns 1024)\nconst truncatedEmbedding = avgEmbedding.slice(0, 768);\n\n// Get document ID from first item\nconst document_id = items[0].json.document_id || $('Chunk Content').first().json.document_id;\n\nreturn [{\n  json: {\n    document_id: document_id,\n    embedding: truncatedEmbedding,\n    dimensions: truncatedEmbedding.length,\n    chunks_processed: items.length\n  }\n}];"
      },
      "name": "Average Embeddings",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=UPDATE documents SET embedding = '{{ JSON.stringify($json.embedding) }}'::vector WHERE id = '{{ $json.document_id }}'::uuid",
        "options": {}
      },
      "name": "Store Embedding",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1250, 300],
      "credentials": {
        "postgres": {
          "name": "PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": true, \"document_id\": $json.document_id, \"dimensions\": $json.dimensions, \"chunks_processed\": $json.chunks_processed } }}"
      },
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1450, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Get Document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Document": {
      "main": [
        [
          {
            "node": "Chunk Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk Content": {
      "main": [
        [
          {
            "node": "Cohere Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cohere Embedding": {
      "main": [
        [
          {
            "node": "Average Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Average Embeddings": {
      "main": [
        [
          {
            "node": "Store Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Embedding": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
